//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 RppLexer.g3 2016-07-18 22:48:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace CSharpRpp
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class RppLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int BooleanLiteral=4;
	public const int CharEscapeSeq=5;
	public const int DecimalNumber=6;
	public const int Digit=7;
	public const int ExponentPart=8;
	public const int FloatType=9;
	public const int FloatingPointLiteral=10;
	public const int HexDigit=11;
	public const int HexNumeral=12;
	public const int Id=13;
	public const int IntegerLiteral=14;
	public const int InterpolatedStringLiteral=15;
	public const int KW_Abstract=16;
	public const int KW_Case=17;
	public const int KW_Catch=18;
	public const int KW_Class=19;
	public const int KW_Def=20;
	public const int KW_Do=21;
	public const int KW_Else=22;
	public const int KW_Extends=23;
	public const int KW_Final=24;
	public const int KW_For=25;
	public const int KW_ForSome=26;
	public const int KW_If=27;
	public const int KW_Implicit=28;
	public const int KW_Import=29;
	public const int KW_Lazy=30;
	public const int KW_Match=31;
	public const int KW_New=32;
	public const int KW_Null=33;
	public const int KW_Object=34;
	public const int KW_Override=35;
	public const int KW_Package=36;
	public const int KW_Private=37;
	public const int KW_Protected=38;
	public const int KW_Return=39;
	public const int KW_Sealed=40;
	public const int KW_Super=41;
	public const int KW_Throw=42;
	public const int KW_Trait=43;
	public const int KW_Try=44;
	public const int KW_Type=45;
	public const int KW_Val=46;
	public const int KW_Var=47;
	public const int KW_While=48;
	public const int KW_With=49;
	public const int KW_Yield=50;
	public const int NewLine=51;
	public const int NonZeroDigit=52;
	public const int OP_At=53;
	public const int OP_Bar=54;
	public const int OP_Colon=55;
	public const int OP_Comma=56;
	public const int OP_Dot=57;
	public const int OP_Eq=58;
	public const int OP_Follow=59;
	public const int OP_LBrace=60;
	public const int OP_LBracket=61;
	public const int OP_LParen=62;
	public const int OP_Ops=63;
	public const int OP_RBrace=64;
	public const int OP_RBracket=65;
	public const int OP_RParen=66;
	public const int OP_Semi=67;
	public const int OP_Star=68;
	public const int OP_Unary=69;
	public const int OP_Underscore=70;
	public const int OP_Upper=71;
	public const int PrintableChar=72;
	public const int StringElement=73;
	public const int StringLiteral=74;
	public const int WS=75;

	// delegates
	// delegators

	public RppLexer()
	{
		OnCreated();
	}

	public RppLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public RppLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "RppLexer.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_KW_Package();
	partial void LeaveRule_KW_Package();

	// $ANTLR start "KW_Package"
	[GrammarRule("KW_Package")]
	private void mKW_Package()
	{
		EnterRule_KW_Package();
		EnterRule("KW_Package", 1);
		TraceIn("KW_Package", 1);
		try
		{
			int _type = KW_Package;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:10:12: ( 'package' )
			DebugEnterAlt(1);
			// RppLexer.g3:10:14: 'package'
			{
			DebugLocation(10, 14);
			Match("package"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Package", 1);
			LeaveRule("KW_Package", 1);
			LeaveRule_KW_Package();
		}
	}
	// $ANTLR end "KW_Package"

	partial void EnterRule_KW_Abstract();
	partial void LeaveRule_KW_Abstract();

	// $ANTLR start "KW_Abstract"
	[GrammarRule("KW_Abstract")]
	private void mKW_Abstract()
	{
		EnterRule_KW_Abstract();
		EnterRule("KW_Abstract", 2);
		TraceIn("KW_Abstract", 2);
		try
		{
			int _type = KW_Abstract;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:11:13: ( 'abstract' )
			DebugEnterAlt(1);
			// RppLexer.g3:11:15: 'abstract'
			{
			DebugLocation(11, 15);
			Match("abstract"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Abstract", 2);
			LeaveRule("KW_Abstract", 2);
			LeaveRule_KW_Abstract();
		}
	}
	// $ANTLR end "KW_Abstract"

	partial void EnterRule_KW_Case();
	partial void LeaveRule_KW_Case();

	// $ANTLR start "KW_Case"
	[GrammarRule("KW_Case")]
	private void mKW_Case()
	{
		EnterRule_KW_Case();
		EnterRule("KW_Case", 3);
		TraceIn("KW_Case", 3);
		try
		{
			int _type = KW_Case;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:12:9: ( 'case' )
			DebugEnterAlt(1);
			// RppLexer.g3:12:11: 'case'
			{
			DebugLocation(12, 11);
			Match("case"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Case", 3);
			LeaveRule("KW_Case", 3);
			LeaveRule_KW_Case();
		}
	}
	// $ANTLR end "KW_Case"

	partial void EnterRule_KW_Catch();
	partial void LeaveRule_KW_Catch();

	// $ANTLR start "KW_Catch"
	[GrammarRule("KW_Catch")]
	private void mKW_Catch()
	{
		EnterRule_KW_Catch();
		EnterRule("KW_Catch", 4);
		TraceIn("KW_Catch", 4);
		try
		{
			int _type = KW_Catch;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:13:10: ( 'catch' )
			DebugEnterAlt(1);
			// RppLexer.g3:13:12: 'catch'
			{
			DebugLocation(13, 12);
			Match("catch"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Catch", 4);
			LeaveRule("KW_Catch", 4);
			LeaveRule_KW_Catch();
		}
	}
	// $ANTLR end "KW_Catch"

	partial void EnterRule_KW_Class();
	partial void LeaveRule_KW_Class();

	// $ANTLR start "KW_Class"
	[GrammarRule("KW_Class")]
	private void mKW_Class()
	{
		EnterRule_KW_Class();
		EnterRule("KW_Class", 5);
		TraceIn("KW_Class", 5);
		try
		{
			int _type = KW_Class;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:14:10: ( 'class' )
			DebugEnterAlt(1);
			// RppLexer.g3:14:12: 'class'
			{
			DebugLocation(14, 12);
			Match("class"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Class", 5);
			LeaveRule("KW_Class", 5);
			LeaveRule_KW_Class();
		}
	}
	// $ANTLR end "KW_Class"

	partial void EnterRule_KW_Def();
	partial void LeaveRule_KW_Def();

	// $ANTLR start "KW_Def"
	[GrammarRule("KW_Def")]
	private void mKW_Def()
	{
		EnterRule_KW_Def();
		EnterRule("KW_Def", 6);
		TraceIn("KW_Def", 6);
		try
		{
			int _type = KW_Def;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:15:8: ( 'def' )
			DebugEnterAlt(1);
			// RppLexer.g3:15:10: 'def'
			{
			DebugLocation(15, 10);
			Match("def"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Def", 6);
			LeaveRule("KW_Def", 6);
			LeaveRule_KW_Def();
		}
	}
	// $ANTLR end "KW_Def"

	partial void EnterRule_KW_Do();
	partial void LeaveRule_KW_Do();

	// $ANTLR start "KW_Do"
	[GrammarRule("KW_Do")]
	private void mKW_Do()
	{
		EnterRule_KW_Do();
		EnterRule("KW_Do", 7);
		TraceIn("KW_Do", 7);
		try
		{
			int _type = KW_Do;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:16:7: ( 'do' )
			DebugEnterAlt(1);
			// RppLexer.g3:16:9: 'do'
			{
			DebugLocation(16, 9);
			Match("do"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Do", 7);
			LeaveRule("KW_Do", 7);
			LeaveRule_KW_Do();
		}
	}
	// $ANTLR end "KW_Do"

	partial void EnterRule_KW_Else();
	partial void LeaveRule_KW_Else();

	// $ANTLR start "KW_Else"
	[GrammarRule("KW_Else")]
	private void mKW_Else()
	{
		EnterRule_KW_Else();
		EnterRule("KW_Else", 8);
		TraceIn("KW_Else", 8);
		try
		{
			int _type = KW_Else;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:17:9: ( 'else' )
			DebugEnterAlt(1);
			// RppLexer.g3:17:11: 'else'
			{
			DebugLocation(17, 11);
			Match("else"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Else", 8);
			LeaveRule("KW_Else", 8);
			LeaveRule_KW_Else();
		}
	}
	// $ANTLR end "KW_Else"

	partial void EnterRule_KW_Extends();
	partial void LeaveRule_KW_Extends();

	// $ANTLR start "KW_Extends"
	[GrammarRule("KW_Extends")]
	private void mKW_Extends()
	{
		EnterRule_KW_Extends();
		EnterRule("KW_Extends", 9);
		TraceIn("KW_Extends", 9);
		try
		{
			int _type = KW_Extends;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:18:12: ( 'extends' )
			DebugEnterAlt(1);
			// RppLexer.g3:18:14: 'extends'
			{
			DebugLocation(18, 14);
			Match("extends"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Extends", 9);
			LeaveRule("KW_Extends", 9);
			LeaveRule_KW_Extends();
		}
	}
	// $ANTLR end "KW_Extends"

	partial void EnterRule_KW_Final();
	partial void LeaveRule_KW_Final();

	// $ANTLR start "KW_Final"
	[GrammarRule("KW_Final")]
	private void mKW_Final()
	{
		EnterRule_KW_Final();
		EnterRule("KW_Final", 10);
		TraceIn("KW_Final", 10);
		try
		{
			int _type = KW_Final;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:19:10: ( 'final' )
			DebugEnterAlt(1);
			// RppLexer.g3:19:12: 'final'
			{
			DebugLocation(19, 12);
			Match("final"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Final", 10);
			LeaveRule("KW_Final", 10);
			LeaveRule_KW_Final();
		}
	}
	// $ANTLR end "KW_Final"

	partial void EnterRule_KW_For();
	partial void LeaveRule_KW_For();

	// $ANTLR start "KW_For"
	[GrammarRule("KW_For")]
	private void mKW_For()
	{
		EnterRule_KW_For();
		EnterRule("KW_For", 11);
		TraceIn("KW_For", 11);
		try
		{
			int _type = KW_For;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:20:8: ( 'for' )
			DebugEnterAlt(1);
			// RppLexer.g3:20:10: 'for'
			{
			DebugLocation(20, 10);
			Match("for"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_For", 11);
			LeaveRule("KW_For", 11);
			LeaveRule_KW_For();
		}
	}
	// $ANTLR end "KW_For"

	partial void EnterRule_KW_ForSome();
	partial void LeaveRule_KW_ForSome();

	// $ANTLR start "KW_ForSome"
	[GrammarRule("KW_ForSome")]
	private void mKW_ForSome()
	{
		EnterRule_KW_ForSome();
		EnterRule("KW_ForSome", 12);
		TraceIn("KW_ForSome", 12);
		try
		{
			int _type = KW_ForSome;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:21:12: ( 'forSome' )
			DebugEnterAlt(1);
			// RppLexer.g3:21:14: 'forSome'
			{
			DebugLocation(21, 14);
			Match("forSome"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ForSome", 12);
			LeaveRule("KW_ForSome", 12);
			LeaveRule_KW_ForSome();
		}
	}
	// $ANTLR end "KW_ForSome"

	partial void EnterRule_KW_If();
	partial void LeaveRule_KW_If();

	// $ANTLR start "KW_If"
	[GrammarRule("KW_If")]
	private void mKW_If()
	{
		EnterRule_KW_If();
		EnterRule("KW_If", 13);
		TraceIn("KW_If", 13);
		try
		{
			int _type = KW_If;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:22:7: ( 'if' )
			DebugEnterAlt(1);
			// RppLexer.g3:22:9: 'if'
			{
			DebugLocation(22, 9);
			Match("if"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_If", 13);
			LeaveRule("KW_If", 13);
			LeaveRule_KW_If();
		}
	}
	// $ANTLR end "KW_If"

	partial void EnterRule_KW_Implicit();
	partial void LeaveRule_KW_Implicit();

	// $ANTLR start "KW_Implicit"
	[GrammarRule("KW_Implicit")]
	private void mKW_Implicit()
	{
		EnterRule_KW_Implicit();
		EnterRule("KW_Implicit", 14);
		TraceIn("KW_Implicit", 14);
		try
		{
			int _type = KW_Implicit;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:23:13: ( 'implicit' )
			DebugEnterAlt(1);
			// RppLexer.g3:23:15: 'implicit'
			{
			DebugLocation(23, 15);
			Match("implicit"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Implicit", 14);
			LeaveRule("KW_Implicit", 14);
			LeaveRule_KW_Implicit();
		}
	}
	// $ANTLR end "KW_Implicit"

	partial void EnterRule_KW_Import();
	partial void LeaveRule_KW_Import();

	// $ANTLR start "KW_Import"
	[GrammarRule("KW_Import")]
	private void mKW_Import()
	{
		EnterRule_KW_Import();
		EnterRule("KW_Import", 15);
		TraceIn("KW_Import", 15);
		try
		{
			int _type = KW_Import;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:24:11: ( 'import' )
			DebugEnterAlt(1);
			// RppLexer.g3:24:13: 'import'
			{
			DebugLocation(24, 13);
			Match("import"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Import", 15);
			LeaveRule("KW_Import", 15);
			LeaveRule_KW_Import();
		}
	}
	// $ANTLR end "KW_Import"

	partial void EnterRule_KW_Lazy();
	partial void LeaveRule_KW_Lazy();

	// $ANTLR start "KW_Lazy"
	[GrammarRule("KW_Lazy")]
	private void mKW_Lazy()
	{
		EnterRule_KW_Lazy();
		EnterRule("KW_Lazy", 16);
		TraceIn("KW_Lazy", 16);
		try
		{
			int _type = KW_Lazy;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:25:9: ( 'lazy' )
			DebugEnterAlt(1);
			// RppLexer.g3:25:11: 'lazy'
			{
			DebugLocation(25, 11);
			Match("lazy"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Lazy", 16);
			LeaveRule("KW_Lazy", 16);
			LeaveRule_KW_Lazy();
		}
	}
	// $ANTLR end "KW_Lazy"

	partial void EnterRule_KW_Match();
	partial void LeaveRule_KW_Match();

	// $ANTLR start "KW_Match"
	[GrammarRule("KW_Match")]
	private void mKW_Match()
	{
		EnterRule_KW_Match();
		EnterRule("KW_Match", 17);
		TraceIn("KW_Match", 17);
		try
		{
			int _type = KW_Match;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:26:10: ( 'match' )
			DebugEnterAlt(1);
			// RppLexer.g3:26:12: 'match'
			{
			DebugLocation(26, 12);
			Match("match"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Match", 17);
			LeaveRule("KW_Match", 17);
			LeaveRule_KW_Match();
		}
	}
	// $ANTLR end "KW_Match"

	partial void EnterRule_KW_New();
	partial void LeaveRule_KW_New();

	// $ANTLR start "KW_New"
	[GrammarRule("KW_New")]
	private void mKW_New()
	{
		EnterRule_KW_New();
		EnterRule("KW_New", 18);
		TraceIn("KW_New", 18);
		try
		{
			int _type = KW_New;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:27:8: ( 'new' )
			DebugEnterAlt(1);
			// RppLexer.g3:27:10: 'new'
			{
			DebugLocation(27, 10);
			Match("new"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_New", 18);
			LeaveRule("KW_New", 18);
			LeaveRule_KW_New();
		}
	}
	// $ANTLR end "KW_New"

	partial void EnterRule_KW_Null();
	partial void LeaveRule_KW_Null();

	// $ANTLR start "KW_Null"
	[GrammarRule("KW_Null")]
	private void mKW_Null()
	{
		EnterRule_KW_Null();
		EnterRule("KW_Null", 19);
		TraceIn("KW_Null", 19);
		try
		{
			int _type = KW_Null;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:28:9: ( 'null' )
			DebugEnterAlt(1);
			// RppLexer.g3:28:11: 'null'
			{
			DebugLocation(28, 11);
			Match("null"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Null", 19);
			LeaveRule("KW_Null", 19);
			LeaveRule_KW_Null();
		}
	}
	// $ANTLR end "KW_Null"

	partial void EnterRule_KW_Object();
	partial void LeaveRule_KW_Object();

	// $ANTLR start "KW_Object"
	[GrammarRule("KW_Object")]
	private void mKW_Object()
	{
		EnterRule_KW_Object();
		EnterRule("KW_Object", 20);
		TraceIn("KW_Object", 20);
		try
		{
			int _type = KW_Object;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:29:11: ( 'object' )
			DebugEnterAlt(1);
			// RppLexer.g3:29:13: 'object'
			{
			DebugLocation(29, 13);
			Match("object"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Object", 20);
			LeaveRule("KW_Object", 20);
			LeaveRule_KW_Object();
		}
	}
	// $ANTLR end "KW_Object"

	partial void EnterRule_KW_Override();
	partial void LeaveRule_KW_Override();

	// $ANTLR start "KW_Override"
	[GrammarRule("KW_Override")]
	private void mKW_Override()
	{
		EnterRule_KW_Override();
		EnterRule("KW_Override", 21);
		TraceIn("KW_Override", 21);
		try
		{
			int _type = KW_Override;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:30:13: ( 'override' )
			DebugEnterAlt(1);
			// RppLexer.g3:30:15: 'override'
			{
			DebugLocation(30, 15);
			Match("override"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Override", 21);
			LeaveRule("KW_Override", 21);
			LeaveRule_KW_Override();
		}
	}
	// $ANTLR end "KW_Override"

	partial void EnterRule_KW_Private();
	partial void LeaveRule_KW_Private();

	// $ANTLR start "KW_Private"
	[GrammarRule("KW_Private")]
	private void mKW_Private()
	{
		EnterRule_KW_Private();
		EnterRule("KW_Private", 22);
		TraceIn("KW_Private", 22);
		try
		{
			int _type = KW_Private;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:31:12: ( 'private' )
			DebugEnterAlt(1);
			// RppLexer.g3:31:14: 'private'
			{
			DebugLocation(31, 14);
			Match("private"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Private", 22);
			LeaveRule("KW_Private", 22);
			LeaveRule_KW_Private();
		}
	}
	// $ANTLR end "KW_Private"

	partial void EnterRule_KW_Protected();
	partial void LeaveRule_KW_Protected();

	// $ANTLR start "KW_Protected"
	[GrammarRule("KW_Protected")]
	private void mKW_Protected()
	{
		EnterRule_KW_Protected();
		EnterRule("KW_Protected", 23);
		TraceIn("KW_Protected", 23);
		try
		{
			int _type = KW_Protected;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:32:13: ( 'protected' )
			DebugEnterAlt(1);
			// RppLexer.g3:32:15: 'protected'
			{
			DebugLocation(32, 15);
			Match("protected"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Protected", 23);
			LeaveRule("KW_Protected", 23);
			LeaveRule_KW_Protected();
		}
	}
	// $ANTLR end "KW_Protected"

	partial void EnterRule_KW_Return();
	partial void LeaveRule_KW_Return();

	// $ANTLR start "KW_Return"
	[GrammarRule("KW_Return")]
	private void mKW_Return()
	{
		EnterRule_KW_Return();
		EnterRule("KW_Return", 24);
		TraceIn("KW_Return", 24);
		try
		{
			int _type = KW_Return;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:33:11: ( 'return' )
			DebugEnterAlt(1);
			// RppLexer.g3:33:13: 'return'
			{
			DebugLocation(33, 13);
			Match("return"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Return", 24);
			LeaveRule("KW_Return", 24);
			LeaveRule_KW_Return();
		}
	}
	// $ANTLR end "KW_Return"

	partial void EnterRule_KW_Sealed();
	partial void LeaveRule_KW_Sealed();

	// $ANTLR start "KW_Sealed"
	[GrammarRule("KW_Sealed")]
	private void mKW_Sealed()
	{
		EnterRule_KW_Sealed();
		EnterRule("KW_Sealed", 25);
		TraceIn("KW_Sealed", 25);
		try
		{
			int _type = KW_Sealed;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:34:11: ( 'sealed' )
			DebugEnterAlt(1);
			// RppLexer.g3:34:13: 'sealed'
			{
			DebugLocation(34, 13);
			Match("sealed"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Sealed", 25);
			LeaveRule("KW_Sealed", 25);
			LeaveRule_KW_Sealed();
		}
	}
	// $ANTLR end "KW_Sealed"

	partial void EnterRule_KW_Super();
	partial void LeaveRule_KW_Super();

	// $ANTLR start "KW_Super"
	[GrammarRule("KW_Super")]
	private void mKW_Super()
	{
		EnterRule_KW_Super();
		EnterRule("KW_Super", 26);
		TraceIn("KW_Super", 26);
		try
		{
			int _type = KW_Super;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:35:10: ( 'super' )
			DebugEnterAlt(1);
			// RppLexer.g3:35:12: 'super'
			{
			DebugLocation(35, 12);
			Match("super"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Super", 26);
			LeaveRule("KW_Super", 26);
			LeaveRule_KW_Super();
		}
	}
	// $ANTLR end "KW_Super"

	partial void EnterRule_KW_Throw();
	partial void LeaveRule_KW_Throw();

	// $ANTLR start "KW_Throw"
	[GrammarRule("KW_Throw")]
	private void mKW_Throw()
	{
		EnterRule_KW_Throw();
		EnterRule("KW_Throw", 27);
		TraceIn("KW_Throw", 27);
		try
		{
			int _type = KW_Throw;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:36:10: ( 'throw' )
			DebugEnterAlt(1);
			// RppLexer.g3:36:12: 'throw'
			{
			DebugLocation(36, 12);
			Match("throw"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Throw", 27);
			LeaveRule("KW_Throw", 27);
			LeaveRule_KW_Throw();
		}
	}
	// $ANTLR end "KW_Throw"

	partial void EnterRule_KW_Trait();
	partial void LeaveRule_KW_Trait();

	// $ANTLR start "KW_Trait"
	[GrammarRule("KW_Trait")]
	private void mKW_Trait()
	{
		EnterRule_KW_Trait();
		EnterRule("KW_Trait", 28);
		TraceIn("KW_Trait", 28);
		try
		{
			int _type = KW_Trait;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:37:10: ( 'trait' )
			DebugEnterAlt(1);
			// RppLexer.g3:37:12: 'trait'
			{
			DebugLocation(37, 12);
			Match("trait"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Trait", 28);
			LeaveRule("KW_Trait", 28);
			LeaveRule_KW_Trait();
		}
	}
	// $ANTLR end "KW_Trait"

	partial void EnterRule_KW_Try();
	partial void LeaveRule_KW_Try();

	// $ANTLR start "KW_Try"
	[GrammarRule("KW_Try")]
	private void mKW_Try()
	{
		EnterRule_KW_Try();
		EnterRule("KW_Try", 29);
		TraceIn("KW_Try", 29);
		try
		{
			int _type = KW_Try;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:38:8: ( 'try' )
			DebugEnterAlt(1);
			// RppLexer.g3:38:10: 'try'
			{
			DebugLocation(38, 10);
			Match("try"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Try", 29);
			LeaveRule("KW_Try", 29);
			LeaveRule_KW_Try();
		}
	}
	// $ANTLR end "KW_Try"

	partial void EnterRule_KW_Type();
	partial void LeaveRule_KW_Type();

	// $ANTLR start "KW_Type"
	[GrammarRule("KW_Type")]
	private void mKW_Type()
	{
		EnterRule_KW_Type();
		EnterRule("KW_Type", 30);
		TraceIn("KW_Type", 30);
		try
		{
			int _type = KW_Type;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:39:9: ( 'type' )
			DebugEnterAlt(1);
			// RppLexer.g3:39:11: 'type'
			{
			DebugLocation(39, 11);
			Match("type"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Type", 30);
			LeaveRule("KW_Type", 30);
			LeaveRule_KW_Type();
		}
	}
	// $ANTLR end "KW_Type"

	partial void EnterRule_KW_Val();
	partial void LeaveRule_KW_Val();

	// $ANTLR start "KW_Val"
	[GrammarRule("KW_Val")]
	private void mKW_Val()
	{
		EnterRule_KW_Val();
		EnterRule("KW_Val", 31);
		TraceIn("KW_Val", 31);
		try
		{
			int _type = KW_Val;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:40:8: ( 'val' )
			DebugEnterAlt(1);
			// RppLexer.g3:40:10: 'val'
			{
			DebugLocation(40, 10);
			Match("val"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Val", 31);
			LeaveRule("KW_Val", 31);
			LeaveRule_KW_Val();
		}
	}
	// $ANTLR end "KW_Val"

	partial void EnterRule_KW_Var();
	partial void LeaveRule_KW_Var();

	// $ANTLR start "KW_Var"
	[GrammarRule("KW_Var")]
	private void mKW_Var()
	{
		EnterRule_KW_Var();
		EnterRule("KW_Var", 32);
		TraceIn("KW_Var", 32);
		try
		{
			int _type = KW_Var;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:41:8: ( 'var' )
			DebugEnterAlt(1);
			// RppLexer.g3:41:10: 'var'
			{
			DebugLocation(41, 10);
			Match("var"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Var", 32);
			LeaveRule("KW_Var", 32);
			LeaveRule_KW_Var();
		}
	}
	// $ANTLR end "KW_Var"

	partial void EnterRule_KW_While();
	partial void LeaveRule_KW_While();

	// $ANTLR start "KW_While"
	[GrammarRule("KW_While")]
	private void mKW_While()
	{
		EnterRule_KW_While();
		EnterRule("KW_While", 33);
		TraceIn("KW_While", 33);
		try
		{
			int _type = KW_While;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:42:10: ( 'while' )
			DebugEnterAlt(1);
			// RppLexer.g3:42:12: 'while'
			{
			DebugLocation(42, 12);
			Match("while"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_While", 33);
			LeaveRule("KW_While", 33);
			LeaveRule_KW_While();
		}
	}
	// $ANTLR end "KW_While"

	partial void EnterRule_KW_With();
	partial void LeaveRule_KW_With();

	// $ANTLR start "KW_With"
	[GrammarRule("KW_With")]
	private void mKW_With()
	{
		EnterRule_KW_With();
		EnterRule("KW_With", 34);
		TraceIn("KW_With", 34);
		try
		{
			int _type = KW_With;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:43:9: ( 'with' )
			DebugEnterAlt(1);
			// RppLexer.g3:43:11: 'with'
			{
			DebugLocation(43, 11);
			Match("with"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_With", 34);
			LeaveRule("KW_With", 34);
			LeaveRule_KW_With();
		}
	}
	// $ANTLR end "KW_With"

	partial void EnterRule_KW_Yield();
	partial void LeaveRule_KW_Yield();

	// $ANTLR start "KW_Yield"
	[GrammarRule("KW_Yield")]
	private void mKW_Yield()
	{
		EnterRule_KW_Yield();
		EnterRule("KW_Yield", 35);
		TraceIn("KW_Yield", 35);
		try
		{
			int _type = KW_Yield;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:44:10: ( 'yield' )
			DebugEnterAlt(1);
			// RppLexer.g3:44:12: 'yield'
			{
			DebugLocation(44, 12);
			Match("yield"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_Yield", 35);
			LeaveRule("KW_Yield", 35);
			LeaveRule_KW_Yield();
		}
	}
	// $ANTLR end "KW_Yield"

	partial void EnterRule_OP_Semi();
	partial void LeaveRule_OP_Semi();

	// $ANTLR start "OP_Semi"
	[GrammarRule("OP_Semi")]
	private void mOP_Semi()
	{
		EnterRule_OP_Semi();
		EnterRule("OP_Semi", 36);
		TraceIn("OP_Semi", 36);
		try
		{
			int _type = OP_Semi;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:45:9: ( ';' )
			DebugEnterAlt(1);
			// RppLexer.g3:45:11: ';'
			{
			DebugLocation(45, 11);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Semi", 36);
			LeaveRule("OP_Semi", 36);
			LeaveRule_OP_Semi();
		}
	}
	// $ANTLR end "OP_Semi"

	partial void EnterRule_OP_LBracket();
	partial void LeaveRule_OP_LBracket();

	// $ANTLR start "OP_LBracket"
	[GrammarRule("OP_LBracket")]
	private void mOP_LBracket()
	{
		EnterRule_OP_LBracket();
		EnterRule("OP_LBracket", 37);
		TraceIn("OP_LBracket", 37);
		try
		{
			int _type = OP_LBracket;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:46:13: ( '[' )
			DebugEnterAlt(1);
			// RppLexer.g3:46:15: '['
			{
			DebugLocation(46, 15);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_LBracket", 37);
			LeaveRule("OP_LBracket", 37);
			LeaveRule_OP_LBracket();
		}
	}
	// $ANTLR end "OP_LBracket"

	partial void EnterRule_OP_RBracket();
	partial void LeaveRule_OP_RBracket();

	// $ANTLR start "OP_RBracket"
	[GrammarRule("OP_RBracket")]
	private void mOP_RBracket()
	{
		EnterRule_OP_RBracket();
		EnterRule("OP_RBracket", 38);
		TraceIn("OP_RBracket", 38);
		try
		{
			int _type = OP_RBracket;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:47:13: ( ']' )
			DebugEnterAlt(1);
			// RppLexer.g3:47:15: ']'
			{
			DebugLocation(47, 15);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_RBracket", 38);
			LeaveRule("OP_RBracket", 38);
			LeaveRule_OP_RBracket();
		}
	}
	// $ANTLR end "OP_RBracket"

	partial void EnterRule_OP_LBrace();
	partial void LeaveRule_OP_LBrace();

	// $ANTLR start "OP_LBrace"
	[GrammarRule("OP_LBrace")]
	private void mOP_LBrace()
	{
		EnterRule_OP_LBrace();
		EnterRule("OP_LBrace", 39);
		TraceIn("OP_LBrace", 39);
		try
		{
			int _type = OP_LBrace;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:48:11: ( '{' )
			DebugEnterAlt(1);
			// RppLexer.g3:48:13: '{'
			{
			DebugLocation(48, 13);
			Match('{'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_LBrace", 39);
			LeaveRule("OP_LBrace", 39);
			LeaveRule_OP_LBrace();
		}
	}
	// $ANTLR end "OP_LBrace"

	partial void EnterRule_OP_RBrace();
	partial void LeaveRule_OP_RBrace();

	// $ANTLR start "OP_RBrace"
	[GrammarRule("OP_RBrace")]
	private void mOP_RBrace()
	{
		EnterRule_OP_RBrace();
		EnterRule("OP_RBrace", 40);
		TraceIn("OP_RBrace", 40);
		try
		{
			int _type = OP_RBrace;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:49:11: ( '}' )
			DebugEnterAlt(1);
			// RppLexer.g3:49:13: '}'
			{
			DebugLocation(49, 13);
			Match('}'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_RBrace", 40);
			LeaveRule("OP_RBrace", 40);
			LeaveRule_OP_RBrace();
		}
	}
	// $ANTLR end "OP_RBrace"

	partial void EnterRule_OP_Comma();
	partial void LeaveRule_OP_Comma();

	// $ANTLR start "OP_Comma"
	[GrammarRule("OP_Comma")]
	private void mOP_Comma()
	{
		EnterRule_OP_Comma();
		EnterRule("OP_Comma", 41);
		TraceIn("OP_Comma", 41);
		try
		{
			int _type = OP_Comma;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:50:10: ( ',' )
			DebugEnterAlt(1);
			// RppLexer.g3:50:12: ','
			{
			DebugLocation(50, 12);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Comma", 41);
			LeaveRule("OP_Comma", 41);
			LeaveRule_OP_Comma();
		}
	}
	// $ANTLR end "OP_Comma"

	partial void EnterRule_OP_LParen();
	partial void LeaveRule_OP_LParen();

	// $ANTLR start "OP_LParen"
	[GrammarRule("OP_LParen")]
	private void mOP_LParen()
	{
		EnterRule_OP_LParen();
		EnterRule("OP_LParen", 42);
		TraceIn("OP_LParen", 42);
		try
		{
			int _type = OP_LParen;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:51:11: ( '(' )
			DebugEnterAlt(1);
			// RppLexer.g3:51:13: '('
			{
			DebugLocation(51, 13);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_LParen", 42);
			LeaveRule("OP_LParen", 42);
			LeaveRule_OP_LParen();
		}
	}
	// $ANTLR end "OP_LParen"

	partial void EnterRule_OP_RParen();
	partial void LeaveRule_OP_RParen();

	// $ANTLR start "OP_RParen"
	[GrammarRule("OP_RParen")]
	private void mOP_RParen()
	{
		EnterRule_OP_RParen();
		EnterRule("OP_RParen", 43);
		TraceIn("OP_RParen", 43);
		try
		{
			int _type = OP_RParen;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:52:11: ( ')' )
			DebugEnterAlt(1);
			// RppLexer.g3:52:13: ')'
			{
			DebugLocation(52, 13);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_RParen", 43);
			LeaveRule("OP_RParen", 43);
			LeaveRule_OP_RParen();
		}
	}
	// $ANTLR end "OP_RParen"

	partial void EnterRule_OP_Colon();
	partial void LeaveRule_OP_Colon();

	// $ANTLR start "OP_Colon"
	[GrammarRule("OP_Colon")]
	private void mOP_Colon()
	{
		EnterRule_OP_Colon();
		EnterRule("OP_Colon", 44);
		TraceIn("OP_Colon", 44);
		try
		{
			int _type = OP_Colon;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:53:10: ( ':' )
			DebugEnterAlt(1);
			// RppLexer.g3:53:12: ':'
			{
			DebugLocation(53, 12);
			Match(':'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Colon", 44);
			LeaveRule("OP_Colon", 44);
			LeaveRule_OP_Colon();
		}
	}
	// $ANTLR end "OP_Colon"

	partial void EnterRule_OP_Follow();
	partial void LeaveRule_OP_Follow();

	// $ANTLR start "OP_Follow"
	[GrammarRule("OP_Follow")]
	private void mOP_Follow()
	{
		EnterRule_OP_Follow();
		EnterRule("OP_Follow", 45);
		TraceIn("OP_Follow", 45);
		try
		{
			int _type = OP_Follow;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:54:11: ( '=>' )
			DebugEnterAlt(1);
			// RppLexer.g3:54:13: '=>'
			{
			DebugLocation(54, 13);
			Match("=>"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Follow", 45);
			LeaveRule("OP_Follow", 45);
			LeaveRule_OP_Follow();
		}
	}
	// $ANTLR end "OP_Follow"

	partial void EnterRule_OP_Eq();
	partial void LeaveRule_OP_Eq();

	// $ANTLR start "OP_Eq"
	[GrammarRule("OP_Eq")]
	private void mOP_Eq()
	{
		EnterRule_OP_Eq();
		EnterRule("OP_Eq", 46);
		TraceIn("OP_Eq", 46);
		try
		{
			int _type = OP_Eq;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:55:7: ( '=' )
			DebugEnterAlt(1);
			// RppLexer.g3:55:9: '='
			{
			DebugLocation(55, 9);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Eq", 46);
			LeaveRule("OP_Eq", 46);
			LeaveRule_OP_Eq();
		}
	}
	// $ANTLR end "OP_Eq"

	partial void EnterRule_OP_Dot();
	partial void LeaveRule_OP_Dot();

	// $ANTLR start "OP_Dot"
	[GrammarRule("OP_Dot")]
	private void mOP_Dot()
	{
		EnterRule_OP_Dot();
		EnterRule("OP_Dot", 47);
		TraceIn("OP_Dot", 47);
		try
		{
			int _type = OP_Dot;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:56:8: ( '.' )
			DebugEnterAlt(1);
			// RppLexer.g3:56:10: '.'
			{
			DebugLocation(56, 10);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Dot", 47);
			LeaveRule("OP_Dot", 47);
			LeaveRule_OP_Dot();
		}
	}
	// $ANTLR end "OP_Dot"

	partial void EnterRule_OP_Star();
	partial void LeaveRule_OP_Star();

	// $ANTLR start "OP_Star"
	[GrammarRule("OP_Star")]
	private void mOP_Star()
	{
		EnterRule_OP_Star();
		EnterRule("OP_Star", 48);
		TraceIn("OP_Star", 48);
		try
		{
			int _type = OP_Star;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:57:9: ( '*' )
			DebugEnterAlt(1);
			// RppLexer.g3:57:11: '*'
			{
			DebugLocation(57, 11);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Star", 48);
			LeaveRule("OP_Star", 48);
			LeaveRule_OP_Star();
		}
	}
	// $ANTLR end "OP_Star"

	partial void EnterRule_OP_Upper();
	partial void LeaveRule_OP_Upper();

	// $ANTLR start "OP_Upper"
	[GrammarRule("OP_Upper")]
	private void mOP_Upper()
	{
		EnterRule_OP_Upper();
		EnterRule("OP_Upper", 49);
		TraceIn("OP_Upper", 49);
		try
		{
			int _type = OP_Upper;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:58:10: ( '<:' )
			DebugEnterAlt(1);
			// RppLexer.g3:58:12: '<:'
			{
			DebugLocation(58, 12);
			Match("<:"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Upper", 49);
			LeaveRule("OP_Upper", 49);
			LeaveRule_OP_Upper();
		}
	}
	// $ANTLR end "OP_Upper"

	partial void EnterRule_OP_At();
	partial void LeaveRule_OP_At();

	// $ANTLR start "OP_At"
	[GrammarRule("OP_At")]
	private void mOP_At()
	{
		EnterRule_OP_At();
		EnterRule("OP_At", 50);
		TraceIn("OP_At", 50);
		try
		{
			int _type = OP_At;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:59:7: ( '@' )
			DebugEnterAlt(1);
			// RppLexer.g3:59:9: '@'
			{
			DebugLocation(59, 9);
			Match('@'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_At", 50);
			LeaveRule("OP_At", 50);
			LeaveRule_OP_At();
		}
	}
	// $ANTLR end "OP_At"

	partial void EnterRule_OP_Underscore();
	partial void LeaveRule_OP_Underscore();

	// $ANTLR start "OP_Underscore"
	[GrammarRule("OP_Underscore")]
	private void mOP_Underscore()
	{
		EnterRule_OP_Underscore();
		EnterRule("OP_Underscore", 51);
		TraceIn("OP_Underscore", 51);
		try
		{
			int _type = OP_Underscore;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:60:15: ( '_' )
			DebugEnterAlt(1);
			// RppLexer.g3:60:17: '_'
			{
			DebugLocation(60, 17);
			Match('_'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Underscore", 51);
			LeaveRule("OP_Underscore", 51);
			LeaveRule_OP_Underscore();
		}
	}
	// $ANTLR end "OP_Underscore"

	partial void EnterRule_OP_Bar();
	partial void LeaveRule_OP_Bar();

	// $ANTLR start "OP_Bar"
	[GrammarRule("OP_Bar")]
	private void mOP_Bar()
	{
		EnterRule_OP_Bar();
		EnterRule("OP_Bar", 52);
		TraceIn("OP_Bar", 52);
		try
		{
			int _type = OP_Bar;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:62:8: ( '|' )
			DebugEnterAlt(1);
			// RppLexer.g3:62:10: '|'
			{
			DebugLocation(62, 10);
			Match('|'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Bar", 52);
			LeaveRule("OP_Bar", 52);
			LeaveRule_OP_Bar();
		}
	}
	// $ANTLR end "OP_Bar"

	partial void EnterRule_OP_Unary();
	partial void LeaveRule_OP_Unary();

	// $ANTLR start "OP_Unary"
	[GrammarRule("OP_Unary")]
	private void mOP_Unary()
	{
		EnterRule_OP_Unary();
		EnterRule("OP_Unary", 53);
		TraceIn("OP_Unary", 53);
		try
		{
			int _type = OP_Unary;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:63:9: ( '!' | '~' | '+' | '-' )
			DebugEnterAlt(1);
			// RppLexer.g3:
			{
			DebugLocation(63, 9);
			if (input.LA(1)=='!'||input.LA(1)=='+'||input.LA(1)=='-'||input.LA(1)=='~')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Unary", 53);
			LeaveRule("OP_Unary", 53);
			LeaveRule_OP_Unary();
		}
	}
	// $ANTLR end "OP_Unary"

	partial void EnterRule_OP_Ops();
	partial void LeaveRule_OP_Ops();

	// $ANTLR start "OP_Ops"
	[GrammarRule("OP_Ops")]
	private void mOP_Ops()
	{
		EnterRule_OP_Ops();
		EnterRule("OP_Ops", 54);
		TraceIn("OP_Ops", 54);
		try
		{
			int _type = OP_Ops;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:65:8: ( '|=' | '&=' | '^=' | '+=' | '-=' | '*=' | '/=' | '/' | OP_Star | '%' | '<=' | '>=' | '<' | '>' | '||' | '&&' | '==' | '!=' | '&' | '^' | OP_Bar | OP_Unary )
			int alt1=22;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case '|':
				{
				switch (input.LA(2))
				{
				case '=':
					{
					alt1 = 1;
					}
					break;
				case '|':
					{
					alt1 = 15;
					}
					break;
				default:
					alt1=21;
					break;

				}

				}
				break;
			case '&':
				{
				switch (input.LA(2))
				{
				case '=':
					{
					alt1 = 2;
					}
					break;
				case '&':
					{
					alt1 = 16;
					}
					break;
				default:
					alt1=19;
					break;

				}

				}
				break;
			case '^':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 3;
				}
				else
				{
					alt1 = 20;
				}
				}
				break;
			case '+':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 4;
				}
				else
				{
					alt1 = 22;
				}
				}
				break;
			case '-':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 5;
				}
				else
				{
					alt1 = 22;
				}
				}
				break;
			case '*':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 6;
				}
				else
				{
					alt1 = 9;
				}
				}
				break;
			case '/':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 7;
				}
				else
				{
					alt1 = 8;
				}
				}
				break;
			case '%':
				{
				alt1 = 10;
				}
				break;
			case '<':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 11;
				}
				else
				{
					alt1 = 13;
				}
				}
				break;
			case '>':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 12;
				}
				else
				{
					alt1 = 14;
				}
				}
				break;
			case '=':
				{
				alt1 = 17;
				}
				break;
			case '!':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='='))
				{
					alt1 = 18;
				}
				else
				{
					alt1 = 22;
				}
				}
				break;
			case '~':
				{
				alt1 = 22;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// RppLexer.g3:65:10: '|='
				{
				DebugLocation(65, 10);
				Match("|="); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// RppLexer.g3:65:17: '&='
				{
				DebugLocation(65, 17);
				Match("&="); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// RppLexer.g3:65:24: '^='
				{
				DebugLocation(65, 24);
				Match("^="); 


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// RppLexer.g3:65:30: '+='
				{
				DebugLocation(65, 30);
				Match("+="); 


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// RppLexer.g3:65:37: '-='
				{
				DebugLocation(65, 37);
				Match("-="); 


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// RppLexer.g3:65:44: '*='
				{
				DebugLocation(65, 44);
				Match("*="); 


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// RppLexer.g3:65:51: '/='
				{
				DebugLocation(65, 51);
				Match("/="); 


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// RppLexer.g3:65:58: '/'
				{
				DebugLocation(65, 58);
				Match('/'); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// RppLexer.g3:65:64: OP_Star
				{
				DebugLocation(65, 64);
				mOP_Star(); 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// RppLexer.g3:65:74: '%'
				{
				DebugLocation(65, 74);
				Match('%'); 

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// RppLexer.g3:65:80: '<='
				{
				DebugLocation(65, 80);
				Match("<="); 


				}
				break;
			case 12:
				DebugEnterAlt(12);
				// RppLexer.g3:65:87: '>='
				{
				DebugLocation(65, 87);
				Match(">="); 


				}
				break;
			case 13:
				DebugEnterAlt(13);
				// RppLexer.g3:65:94: '<'
				{
				DebugLocation(65, 94);
				Match('<'); 

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// RppLexer.g3:65:100: '>'
				{
				DebugLocation(65, 100);
				Match('>'); 

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// RppLexer.g3:65:106: '||'
				{
				DebugLocation(65, 106);
				Match("||"); 


				}
				break;
			case 16:
				DebugEnterAlt(16);
				// RppLexer.g3:65:113: '&&'
				{
				DebugLocation(65, 113);
				Match("&&"); 


				}
				break;
			case 17:
				DebugEnterAlt(17);
				// RppLexer.g3:65:120: '=='
				{
				DebugLocation(65, 120);
				Match("=="); 


				}
				break;
			case 18:
				DebugEnterAlt(18);
				// RppLexer.g3:65:127: '!='
				{
				DebugLocation(65, 127);
				Match("!="); 


				}
				break;
			case 19:
				DebugEnterAlt(19);
				// RppLexer.g3:65:134: '&'
				{
				DebugLocation(65, 134);
				Match('&'); 

				}
				break;
			case 20:
				DebugEnterAlt(20);
				// RppLexer.g3:65:140: '^'
				{
				DebugLocation(65, 140);
				Match('^'); 

				}
				break;
			case 21:
				DebugEnterAlt(21);
				// RppLexer.g3:65:146: OP_Bar
				{
				DebugLocation(65, 146);
				mOP_Bar(); 

				}
				break;
			case 22:
				DebugEnterAlt(22);
				// RppLexer.g3:65:155: OP_Unary
				{
				DebugLocation(65, 155);
				mOP_Unary(); 

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_Ops", 54);
			LeaveRule("OP_Ops", 54);
			LeaveRule_OP_Ops();
		}
	}
	// $ANTLR end "OP_Ops"

	partial void EnterRule_BooleanLiteral();
	partial void LeaveRule_BooleanLiteral();

	// $ANTLR start "BooleanLiteral"
	[GrammarRule("BooleanLiteral")]
	private void mBooleanLiteral()
	{
		EnterRule_BooleanLiteral();
		EnterRule("BooleanLiteral", 55);
		TraceIn("BooleanLiteral", 55);
		try
		{
			int _type = BooleanLiteral;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:67:18: ( 'true' | 'false' )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1=='t'))
			{
				alt2 = 1;
			}
			else if ((LA2_1=='f'))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// RppLexer.g3:67:21: 'true'
				{
				DebugLocation(67, 21);
				Match("true"); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// RppLexer.g3:67:30: 'false'
				{
				DebugLocation(67, 30);
				Match("false"); 


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BooleanLiteral", 55);
			LeaveRule("BooleanLiteral", 55);
			LeaveRule_BooleanLiteral();
		}
	}
	// $ANTLR end "BooleanLiteral"

	partial void EnterRule_Id();
	partial void LeaveRule_Id();

	// $ANTLR start "Id"
	[GrammarRule("Id")]
	private void mId()
	{
		EnterRule_Id();
		EnterRule("Id", 56);
		TraceIn("Id", 56);
		try
		{
			int _type = Id;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:68:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' )* )
			DebugEnterAlt(1);
			// RppLexer.g3:68:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' )*
			{
			DebugLocation(68, 6);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(68, 39);
			// RppLexer.g3:68:39: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if (((LA3_1>='0' && LA3_1<='9')||(LA3_1>='A' && LA3_1<='Z')||(LA3_1>='a' && LA3_1<='z')))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:
					{
					DebugLocation(68, 39);
					input.Consume();


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Id", 56);
			LeaveRule("Id", 56);
			LeaveRule_Id();
		}
	}
	// $ANTLR end "Id"

	partial void EnterRule_NewLine();
	partial void LeaveRule_NewLine();

	// $ANTLR start "NewLine"
	[GrammarRule("NewLine")]
	private void mNewLine()
	{
		EnterRule_NewLine();
		EnterRule("NewLine", 57);
		TraceIn("NewLine", 57);
		try
		{
			int _type = NewLine;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:70:23: ( ( '\\r' )? '\\n' )
			DebugEnterAlt(1);
			// RppLexer.g3:70:26: ( '\\r' )? '\\n'
			{
			DebugLocation(70, 26);
			// RppLexer.g3:70:26: ( '\\r' )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1=='\r'))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// RppLexer.g3:70:26: '\\r'
				{
				DebugLocation(70, 26);
				Match('\r'); 

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(70, 32);
			Match('\n'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NewLine", 57);
			LeaveRule("NewLine", 57);
			LeaveRule_NewLine();
		}
	}
	// $ANTLR end "NewLine"

	partial void EnterRule_IntegerLiteral();
	partial void LeaveRule_IntegerLiteral();

	// $ANTLR start "IntegerLiteral"
	[GrammarRule("IntegerLiteral")]
	private void mIntegerLiteral()
	{
		EnterRule_IntegerLiteral();
		EnterRule("IntegerLiteral", 58);
		TraceIn("IntegerLiteral", 58);
		try
		{
			int _type = IntegerLiteral;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:71:16: ( ( DecimalNumber ) ( 'L' | 'l' )? )
			DebugEnterAlt(1);
			// RppLexer.g3:71:18: ( DecimalNumber ) ( 'L' | 'l' )?
			{
			DebugLocation(71, 18);
			// RppLexer.g3:71:18: ( DecimalNumber )
			DebugEnterAlt(1);
			// RppLexer.g3:71:19: DecimalNumber
			{
			DebugLocation(71, 19);
			mDecimalNumber(); 

			}

			DebugLocation(71, 34);
			// RppLexer.g3:71:34: ( 'L' | 'l' )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1=='L'||LA5_1=='l'))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// RppLexer.g3:
				{
				DebugLocation(71, 34);
				input.Consume();


				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IntegerLiteral", 58);
			LeaveRule("IntegerLiteral", 58);
			LeaveRule_IntegerLiteral();
		}
	}
	// $ANTLR end "IntegerLiteral"

	partial void EnterRule_FloatingPointLiteral();
	partial void LeaveRule_FloatingPointLiteral();

	// $ANTLR start "FloatingPointLiteral"
	[GrammarRule("FloatingPointLiteral")]
	private void mFloatingPointLiteral()
	{
		EnterRule_FloatingPointLiteral();
		EnterRule("FloatingPointLiteral", 59);
		TraceIn("FloatingPointLiteral", 59);
		try
		{
			int _type = FloatingPointLiteral;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:73:18: ( ( Digit )+ '.' ( Digit )+ ( ExponentPart )? ( FloatType )? | '.' ( Digit )+ ( ExponentPart )? ( FloatType )? )
			int alt13=2;
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if (((LA13_1>='0' && LA13_1<='9')))
			{
				alt13 = 1;
			}
			else if ((LA13_1=='.'))
			{
				alt13 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// RppLexer.g3:73:21: ( Digit )+ '.' ( Digit )+ ( ExponentPart )? ( FloatType )?
				{
				DebugLocation(73, 21);
				// RppLexer.g3:73:21: ( Digit )+
				int cnt6=0;
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if (((LA6_1>='0' && LA6_1<='9')))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// RppLexer.g3:
						{
						DebugLocation(73, 21);
						input.Consume();


						}
						break;

					default:
						if (cnt6 >= 1)
							goto loop6;

						EarlyExitException eee6 = new EarlyExitException( 6, input );
						DebugRecognitionException(eee6);
						throw eee6;
					}
					cnt6++;
				}
				loop6:
					;

				} finally { DebugExitSubRule(6); }

				DebugLocation(73, 28);
				Match('.'); 
				DebugLocation(73, 32);
				// RppLexer.g3:73:32: ( Digit )+
				int cnt7=0;
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_1 = input.LA(1);

					if (((LA7_1>='0' && LA7_1<='9')))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// RppLexer.g3:
						{
						DebugLocation(73, 32);
						input.Consume();


						}
						break;

					default:
						if (cnt7 >= 1)
							goto loop7;

						EarlyExitException eee7 = new EarlyExitException( 7, input );
						DebugRecognitionException(eee7);
						throw eee7;
					}
					cnt7++;
				}
				loop7:
					;

				} finally { DebugExitSubRule(7); }

				DebugLocation(73, 39);
				// RppLexer.g3:73:39: ( ExponentPart )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1=='E'||LA8_1=='e'))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:73:39: ExponentPart
					{
					DebugLocation(73, 39);
					mExponentPart(); 

					}
					break;

				}
				} finally { DebugExitSubRule(8); }

				DebugLocation(73, 53);
				// RppLexer.g3:73:53: ( FloatType )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1=='D'||LA9_1=='F'||LA9_1=='d'||LA9_1=='f'))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:
					{
					DebugLocation(73, 53);
					input.Consume();


					}
					break;

				}
				} finally { DebugExitSubRule(9); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// RppLexer.g3:74:21: '.' ( Digit )+ ( ExponentPart )? ( FloatType )?
				{
				DebugLocation(74, 21);
				Match('.'); 
				DebugLocation(74, 25);
				// RppLexer.g3:74:25: ( Digit )+
				int cnt10=0;
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if (((LA10_1>='0' && LA10_1<='9')))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch (alt10)
					{
					case 1:
						DebugEnterAlt(1);
						// RppLexer.g3:
						{
						DebugLocation(74, 25);
						input.Consume();


						}
						break;

					default:
						if (cnt10 >= 1)
							goto loop10;

						EarlyExitException eee10 = new EarlyExitException( 10, input );
						DebugRecognitionException(eee10);
						throw eee10;
					}
					cnt10++;
				}
				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(74, 32);
				// RppLexer.g3:74:32: ( ExponentPart )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1=='E'||LA11_1=='e'))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:74:32: ExponentPart
					{
					DebugLocation(74, 32);
					mExponentPart(); 

					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(74, 46);
				// RppLexer.g3:74:46: ( FloatType )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1=='D'||LA12_1=='F'||LA12_1=='d'||LA12_1=='f'))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:
					{
					DebugLocation(74, 46);
					input.Consume();


					}
					break;

				}
				} finally { DebugExitSubRule(12); }


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FloatingPointLiteral", 59);
			LeaveRule("FloatingPointLiteral", 59);
			LeaveRule_FloatingPointLiteral();
		}
	}
	// $ANTLR end "FloatingPointLiteral"

	partial void EnterRule_InterpolatedStringLiteral();
	partial void LeaveRule_InterpolatedStringLiteral();

	// $ANTLR start "InterpolatedStringLiteral"
	[GrammarRule("InterpolatedStringLiteral")]
	private void mInterpolatedStringLiteral()
	{
		EnterRule_InterpolatedStringLiteral();
		EnterRule("InterpolatedStringLiteral", 60);
		TraceIn("InterpolatedStringLiteral", 60);
		try
		{
			int _type = InterpolatedStringLiteral;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:76:27: ( 's' '\"' ( StringElement )* '\"' )
			DebugEnterAlt(1);
			// RppLexer.g3:77:15: 's' '\"' ( StringElement )* '\"'
			{
			DebugLocation(77, 15);
			Match('s'); 
			DebugLocation(77, 19);
			Match('\"'); 
			DebugLocation(77, 23);
			// RppLexer.g3:77:23: ( StringElement )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if (((LA14_1>=' ' && LA14_1<='!')||(LA14_1>='#' && LA14_1<='\u007F')))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:77:23: StringElement
					{
					DebugLocation(77, 23);
					mStringElement(); 

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(77, 38);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("InterpolatedStringLiteral", 60);
			LeaveRule("InterpolatedStringLiteral", 60);
			LeaveRule_InterpolatedStringLiteral();
		}
	}
	// $ANTLR end "InterpolatedStringLiteral"

	partial void EnterRule_StringLiteral();
	partial void LeaveRule_StringLiteral();

	// $ANTLR start "StringLiteral"
	[GrammarRule("StringLiteral")]
	private void mStringLiteral()
	{
		EnterRule_StringLiteral();
		EnterRule("StringLiteral", 61);
		TraceIn("StringLiteral", 61);
		try
		{
			int _type = StringLiteral;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:79:15: ( '\"' ( StringElement )* '\"' )
			DebugEnterAlt(1);
			// RppLexer.g3:80:15: '\"' ( StringElement )* '\"'
			{
			DebugLocation(80, 15);
			Match('\"'); 
			DebugLocation(80, 19);
			// RppLexer.g3:80:19: ( StringElement )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if (((LA15_1>=' ' && LA15_1<='!')||(LA15_1>='#' && LA15_1<='\u007F')))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:80:19: StringElement
					{
					DebugLocation(80, 19);
					mStringElement(); 

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(80, 34);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("StringLiteral", 61);
			LeaveRule("StringLiteral", 61);
			LeaveRule_StringLiteral();
		}
	}
	// $ANTLR end "StringLiteral"

	partial void EnterRule_StringElement();
	partial void LeaveRule_StringElement();

	// $ANTLR start "StringElement"
	[GrammarRule("StringElement")]
	private void mStringElement()
	{
		EnterRule_StringElement();
		EnterRule("StringElement", 62);
		TraceIn("StringElement", 62);
		try
		{
			// RppLexer.g3:83:24: ( '\\u0020' | '\\u0021' | '\\u0023' .. '\\u007F' | CharEscapeSeq )
			int alt16=4;
			try { DebugEnterDecision(16, false);
			switch (input.LA(1))
			{
			case ' ':
				{
				alt16 = 1;
				}
				break;
			case '!':
				{
				alt16 = 2;
				}
				break;
			case '\\':
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2=='\"'||LA16_2=='\''||LA16_2=='\\'||LA16_2=='b'||LA16_2=='f'||LA16_2=='n'||LA16_2=='r'||LA16_2=='t'))
				{
					alt16 = 4;
				}
				else
				{
					alt16 = 3;
				}
				}
				break;
			case '#':
			case '$':
			case '%':
			case '&':
			case '\'':
			case '(':
			case ')':
			case '*':
			case '+':
			case ',':
			case '-':
			case '.':
			case '/':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case ':':
			case ';':
			case '<':
			case '=':
			case '>':
			case '?':
			case '@':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '[':
			case ']':
			case '^':
			case '_':
			case '`':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':
			case '{':
			case '|':
			case '}':
			case '~':
			case '\u007F':
				{
				alt16 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// RppLexer.g3:83:26: '\\u0020'
				{
				DebugLocation(83, 26);
				Match(' '); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// RppLexer.g3:83:36: '\\u0021'
				{
				DebugLocation(83, 36);
				Match('!'); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// RppLexer.g3:83:45: '\\u0023' .. '\\u007F'
				{
				DebugLocation(83, 54);
				MatchRange('#','\u007F'); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// RppLexer.g3:83:68: CharEscapeSeq
				{
				DebugLocation(83, 68);
				mCharEscapeSeq(); 

				}
				break;

			}
		}
		finally
		{
			TraceOut("StringElement", 62);
			LeaveRule("StringElement", 62);
			LeaveRule_StringElement();
		}
	}
	// $ANTLR end "StringElement"

	partial void EnterRule_DecimalNumber();
	partial void LeaveRule_DecimalNumber();

	// $ANTLR start "DecimalNumber"
	[GrammarRule("DecimalNumber")]
	private void mDecimalNumber()
	{
		EnterRule_DecimalNumber();
		EnterRule("DecimalNumber", 63);
		TraceIn("DecimalNumber", 63);
		try
		{
			// RppLexer.g3:85:23: ( ( Digit )+ )
			DebugEnterAlt(1);
			// RppLexer.g3:85:25: ( Digit )+
			{
			DebugLocation(85, 25);
			// RppLexer.g3:85:25: ( Digit )+
			int cnt17=0;
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if (((LA17_1>='0' && LA17_1<='9')))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:
					{
					DebugLocation(85, 25);
					input.Consume();


					}
					break;

				default:
					if (cnt17 >= 1)
						goto loop17;

					EarlyExitException eee17 = new EarlyExitException( 17, input );
					DebugRecognitionException(eee17);
					throw eee17;
				}
				cnt17++;
			}
			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

		}
		finally
		{
			TraceOut("DecimalNumber", 63);
			LeaveRule("DecimalNumber", 63);
			LeaveRule_DecimalNumber();
		}
	}
	// $ANTLR end "DecimalNumber"

	partial void EnterRule_HexNumeral();
	partial void LeaveRule_HexNumeral();

	// $ANTLR start "HexNumeral"
	[GrammarRule("HexNumeral")]
	private void mHexNumeral()
	{
		EnterRule_HexNumeral();
		EnterRule("HexNumeral", 64);
		TraceIn("HexNumeral", 64);
		try
		{
			// RppLexer.g3:86:21: ( '0' 'x' ( HexDigit )+ )
			DebugEnterAlt(1);
			// RppLexer.g3:86:23: '0' 'x' ( HexDigit )+
			{
			DebugLocation(86, 23);
			Match('0'); 
			DebugLocation(86, 27);
			Match('x'); 
			DebugLocation(86, 31);
			// RppLexer.g3:86:31: ( HexDigit )+
			int cnt18=0;
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if (((LA18_1>='0' && LA18_1<='9')||(LA18_1>='A' && LA18_1<='F')||(LA18_1>='a' && LA18_1<='f')))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:
					{
					DebugLocation(86, 31);
					input.Consume();


					}
					break;

				default:
					if (cnt18 >= 1)
						goto loop18;

					EarlyExitException eee18 = new EarlyExitException( 18, input );
					DebugRecognitionException(eee18);
					throw eee18;
				}
				cnt18++;
			}
			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

		}
		finally
		{
			TraceOut("HexNumeral", 64);
			LeaveRule("HexNumeral", 64);
			LeaveRule_HexNumeral();
		}
	}
	// $ANTLR end "HexNumeral"

	partial void EnterRule_HexDigit();
	partial void LeaveRule_HexDigit();

	// $ANTLR start "HexDigit"
	[GrammarRule("HexDigit")]
	private void mHexDigit()
	{
		EnterRule_HexDigit();
		EnterRule("HexDigit", 65);
		TraceIn("HexDigit", 65);
		try
		{
			// RppLexer.g3:87:19: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
			DebugEnterAlt(1);
			// RppLexer.g3:
			{
			DebugLocation(87, 19);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("HexDigit", 65);
			LeaveRule("HexDigit", 65);
			LeaveRule_HexDigit();
		}
	}
	// $ANTLR end "HexDigit"

	partial void EnterRule_FloatType();
	partial void LeaveRule_FloatType();

	// $ANTLR start "FloatType"
	[GrammarRule("FloatType")]
	private void mFloatType()
	{
		EnterRule_FloatType();
		EnterRule("FloatType", 66);
		TraceIn("FloatType", 66);
		try
		{
			// RppLexer.g3:88:27: ( 'F' | 'f' | 'D' | 'd' )
			DebugEnterAlt(1);
			// RppLexer.g3:
			{
			DebugLocation(88, 27);
			if (input.LA(1)=='D'||input.LA(1)=='F'||input.LA(1)=='d'||input.LA(1)=='f')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("FloatType", 66);
			LeaveRule("FloatType", 66);
			LeaveRule_FloatType();
		}
	}
	// $ANTLR end "FloatType"

	partial void EnterRule_ExponentPart();
	partial void LeaveRule_ExponentPart();

	// $ANTLR start "ExponentPart"
	[GrammarRule("ExponentPart")]
	private void mExponentPart()
	{
		EnterRule_ExponentPart();
		EnterRule("ExponentPart", 67);
		TraceIn("ExponentPart", 67);
		try
		{
			// RppLexer.g3:89:27: ( ( 'E' | 'e' ) ( '+' | '-' )? ( Digit )+ )
			DebugEnterAlt(1);
			// RppLexer.g3:89:30: ( 'E' | 'e' ) ( '+' | '-' )? ( Digit )+
			{
			DebugLocation(89, 30);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(89, 42);
			// RppLexer.g3:89:42: ( '+' | '-' )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1=='+'||LA19_1=='-'))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// RppLexer.g3:
				{
				DebugLocation(89, 42);
				input.Consume();


				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(89, 55);
			// RppLexer.g3:89:55: ( Digit )+
			int cnt20=0;
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if (((LA20_1>='0' && LA20_1<='9')))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:
					{
					DebugLocation(89, 55);
					input.Consume();


					}
					break;

				default:
					if (cnt20 >= 1)
						goto loop20;

					EarlyExitException eee20 = new EarlyExitException( 20, input );
					DebugRecognitionException(eee20);
					throw eee20;
				}
				cnt20++;
			}
			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

		}
		finally
		{
			TraceOut("ExponentPart", 67);
			LeaveRule("ExponentPart", 67);
			LeaveRule_ExponentPart();
		}
	}
	// $ANTLR end "ExponentPart"

	partial void EnterRule_Digit();
	partial void LeaveRule_Digit();

	// $ANTLR start "Digit"
	[GrammarRule("Digit")]
	private void mDigit()
	{
		EnterRule_Digit();
		EnterRule("Digit", 68);
		TraceIn("Digit", 68);
		try
		{
			// RppLexer.g3:90:16: ( '0' | NonZeroDigit )
			DebugEnterAlt(1);
			// RppLexer.g3:
			{
			DebugLocation(90, 16);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("Digit", 68);
			LeaveRule("Digit", 68);
			LeaveRule_Digit();
		}
	}
	// $ANTLR end "Digit"

	partial void EnterRule_NonZeroDigit();
	partial void LeaveRule_NonZeroDigit();

	// $ANTLR start "NonZeroDigit"
	[GrammarRule("NonZeroDigit")]
	private void mNonZeroDigit()
	{
		EnterRule_NonZeroDigit();
		EnterRule("NonZeroDigit", 69);
		TraceIn("NonZeroDigit", 69);
		try
		{
			// RppLexer.g3:91:23: ( '1' .. '9' )
			DebugEnterAlt(1);
			// RppLexer.g3:
			{
			DebugLocation(91, 23);
			if ((input.LA(1)>='1' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("NonZeroDigit", 69);
			LeaveRule("NonZeroDigit", 69);
			LeaveRule_NonZeroDigit();
		}
	}
	// $ANTLR end "NonZeroDigit"

	partial void EnterRule_PrintableChar();
	partial void LeaveRule_PrintableChar();

	// $ANTLR start "PrintableChar"
	[GrammarRule("PrintableChar")]
	private void mPrintableChar()
	{
		EnterRule_PrintableChar();
		EnterRule("PrintableChar", 70);
		TraceIn("PrintableChar", 70);
		try
		{
			// RppLexer.g3:92:27: ( '\\u0020' .. '\\u007F' )
			DebugEnterAlt(1);
			// RppLexer.g3:
			{
			DebugLocation(92, 27);
			if ((input.LA(1)>=' ' && input.LA(1)<='\u007F'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("PrintableChar", 70);
			LeaveRule("PrintableChar", 70);
			LeaveRule_PrintableChar();
		}
	}
	// $ANTLR end "PrintableChar"

	partial void EnterRule_CharEscapeSeq();
	partial void LeaveRule_CharEscapeSeq();

	// $ANTLR start "CharEscapeSeq"
	[GrammarRule("CharEscapeSeq")]
	private void mCharEscapeSeq()
	{
		EnterRule_CharEscapeSeq();
		EnterRule("CharEscapeSeq", 71);
		TraceIn("CharEscapeSeq", 71);
		try
		{
			// RppLexer.g3:93:27: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\"' | '\\'' | '\\\\' ) )
			DebugEnterAlt(1);
			// RppLexer.g3:93:29: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\"' | '\\'' | '\\\\' )
			{
			DebugLocation(93, 29);
			Match('\\'); 
			DebugLocation(93, 34);
			if (input.LA(1)=='\"'||input.LA(1)=='\''||input.LA(1)=='\\'||input.LA(1)=='b'||input.LA(1)=='f'||input.LA(1)=='n'||input.LA(1)=='r'||input.LA(1)=='t')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("CharEscapeSeq", 71);
			LeaveRule("CharEscapeSeq", 71);
			LeaveRule_CharEscapeSeq();
		}
	}
	// $ANTLR end "CharEscapeSeq"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 72);
		TraceIn("WS", 72);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// RppLexer.g3:95:4: ( ( '\\t' | ' ' | '\\u000C' )+ )
			DebugEnterAlt(1);
			// RppLexer.g3:95:6: ( '\\t' | ' ' | '\\u000C' )+
			{
			DebugLocation(95, 6);
			// RppLexer.g3:95:6: ( '\\t' | ' ' | '\\u000C' )+
			int cnt21=0;
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1=='\t'||LA21_1=='\f'||LA21_1==' '))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// RppLexer.g3:
					{
					DebugLocation(95, 6);
					input.Consume();


					}
					break;

				default:
					if (cnt21 >= 1)
						goto loop21;

					EarlyExitException eee21 = new EarlyExitException( 21, input );
					DebugRecognitionException(eee21);
					throw eee21;
				}
				cnt21++;
			}
			loop21:
				;

			} finally { DebugExitSubRule(21); }

			DebugLocation(95, 33);
			 Skip(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 72);
			LeaveRule("WS", 72);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	public override void mTokens()
	{
		// RppLexer.g3:1:8: ( KW_Package | KW_Abstract | KW_Case | KW_Catch | KW_Class | KW_Def | KW_Do | KW_Else | KW_Extends | KW_Final | KW_For | KW_ForSome | KW_If | KW_Implicit | KW_Import | KW_Lazy | KW_Match | KW_New | KW_Null | KW_Object | KW_Override | KW_Private | KW_Protected | KW_Return | KW_Sealed | KW_Super | KW_Throw | KW_Trait | KW_Try | KW_Type | KW_Val | KW_Var | KW_While | KW_With | KW_Yield | OP_Semi | OP_LBracket | OP_RBracket | OP_LBrace | OP_RBrace | OP_Comma | OP_LParen | OP_RParen | OP_Colon | OP_Follow | OP_Eq | OP_Dot | OP_Star | OP_Upper | OP_At | OP_Underscore | OP_Bar | OP_Unary | OP_Ops | BooleanLiteral | Id | NewLine | IntegerLiteral | FloatingPointLiteral | InterpolatedStringLiteral | StringLiteral | WS )
		int alt22=62;
		try { DebugEnterDecision(22, false);
		try
		{
			alt22 = dfa22.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(22); }
		switch (alt22)
		{
		case 1:
			DebugEnterAlt(1);
			// RppLexer.g3:1:10: KW_Package
			{
			DebugLocation(1, 10);
			mKW_Package(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// RppLexer.g3:1:21: KW_Abstract
			{
			DebugLocation(1, 21);
			mKW_Abstract(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// RppLexer.g3:1:33: KW_Case
			{
			DebugLocation(1, 33);
			mKW_Case(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// RppLexer.g3:1:41: KW_Catch
			{
			DebugLocation(1, 41);
			mKW_Catch(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// RppLexer.g3:1:50: KW_Class
			{
			DebugLocation(1, 50);
			mKW_Class(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// RppLexer.g3:1:59: KW_Def
			{
			DebugLocation(1, 59);
			mKW_Def(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// RppLexer.g3:1:66: KW_Do
			{
			DebugLocation(1, 66);
			mKW_Do(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// RppLexer.g3:1:72: KW_Else
			{
			DebugLocation(1, 72);
			mKW_Else(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// RppLexer.g3:1:80: KW_Extends
			{
			DebugLocation(1, 80);
			mKW_Extends(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// RppLexer.g3:1:91: KW_Final
			{
			DebugLocation(1, 91);
			mKW_Final(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// RppLexer.g3:1:100: KW_For
			{
			DebugLocation(1, 100);
			mKW_For(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// RppLexer.g3:1:107: KW_ForSome
			{
			DebugLocation(1, 107);
			mKW_ForSome(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// RppLexer.g3:1:118: KW_If
			{
			DebugLocation(1, 118);
			mKW_If(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// RppLexer.g3:1:124: KW_Implicit
			{
			DebugLocation(1, 124);
			mKW_Implicit(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// RppLexer.g3:1:136: KW_Import
			{
			DebugLocation(1, 136);
			mKW_Import(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// RppLexer.g3:1:146: KW_Lazy
			{
			DebugLocation(1, 146);
			mKW_Lazy(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// RppLexer.g3:1:154: KW_Match
			{
			DebugLocation(1, 154);
			mKW_Match(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// RppLexer.g3:1:163: KW_New
			{
			DebugLocation(1, 163);
			mKW_New(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// RppLexer.g3:1:170: KW_Null
			{
			DebugLocation(1, 170);
			mKW_Null(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// RppLexer.g3:1:178: KW_Object
			{
			DebugLocation(1, 178);
			mKW_Object(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// RppLexer.g3:1:188: KW_Override
			{
			DebugLocation(1, 188);
			mKW_Override(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// RppLexer.g3:1:200: KW_Private
			{
			DebugLocation(1, 200);
			mKW_Private(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// RppLexer.g3:1:211: KW_Protected
			{
			DebugLocation(1, 211);
			mKW_Protected(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// RppLexer.g3:1:224: KW_Return
			{
			DebugLocation(1, 224);
			mKW_Return(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// RppLexer.g3:1:234: KW_Sealed
			{
			DebugLocation(1, 234);
			mKW_Sealed(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// RppLexer.g3:1:244: KW_Super
			{
			DebugLocation(1, 244);
			mKW_Super(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// RppLexer.g3:1:253: KW_Throw
			{
			DebugLocation(1, 253);
			mKW_Throw(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// RppLexer.g3:1:262: KW_Trait
			{
			DebugLocation(1, 262);
			mKW_Trait(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// RppLexer.g3:1:271: KW_Try
			{
			DebugLocation(1, 271);
			mKW_Try(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// RppLexer.g3:1:278: KW_Type
			{
			DebugLocation(1, 278);
			mKW_Type(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// RppLexer.g3:1:286: KW_Val
			{
			DebugLocation(1, 286);
			mKW_Val(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// RppLexer.g3:1:293: KW_Var
			{
			DebugLocation(1, 293);
			mKW_Var(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// RppLexer.g3:1:300: KW_While
			{
			DebugLocation(1, 300);
			mKW_While(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// RppLexer.g3:1:309: KW_With
			{
			DebugLocation(1, 309);
			mKW_With(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// RppLexer.g3:1:317: KW_Yield
			{
			DebugLocation(1, 317);
			mKW_Yield(); 

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// RppLexer.g3:1:326: OP_Semi
			{
			DebugLocation(1, 326);
			mOP_Semi(); 

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// RppLexer.g3:1:334: OP_LBracket
			{
			DebugLocation(1, 334);
			mOP_LBracket(); 

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// RppLexer.g3:1:346: OP_RBracket
			{
			DebugLocation(1, 346);
			mOP_RBracket(); 

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// RppLexer.g3:1:358: OP_LBrace
			{
			DebugLocation(1, 358);
			mOP_LBrace(); 

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// RppLexer.g3:1:368: OP_RBrace
			{
			DebugLocation(1, 368);
			mOP_RBrace(); 

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// RppLexer.g3:1:378: OP_Comma
			{
			DebugLocation(1, 378);
			mOP_Comma(); 

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// RppLexer.g3:1:387: OP_LParen
			{
			DebugLocation(1, 387);
			mOP_LParen(); 

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// RppLexer.g3:1:397: OP_RParen
			{
			DebugLocation(1, 397);
			mOP_RParen(); 

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// RppLexer.g3:1:407: OP_Colon
			{
			DebugLocation(1, 407);
			mOP_Colon(); 

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// RppLexer.g3:1:416: OP_Follow
			{
			DebugLocation(1, 416);
			mOP_Follow(); 

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// RppLexer.g3:1:426: OP_Eq
			{
			DebugLocation(1, 426);
			mOP_Eq(); 

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// RppLexer.g3:1:432: OP_Dot
			{
			DebugLocation(1, 432);
			mOP_Dot(); 

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// RppLexer.g3:1:439: OP_Star
			{
			DebugLocation(1, 439);
			mOP_Star(); 

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// RppLexer.g3:1:447: OP_Upper
			{
			DebugLocation(1, 447);
			mOP_Upper(); 

			}
			break;
		case 50:
			DebugEnterAlt(50);
			// RppLexer.g3:1:456: OP_At
			{
			DebugLocation(1, 456);
			mOP_At(); 

			}
			break;
		case 51:
			DebugEnterAlt(51);
			// RppLexer.g3:1:462: OP_Underscore
			{
			DebugLocation(1, 462);
			mOP_Underscore(); 

			}
			break;
		case 52:
			DebugEnterAlt(52);
			// RppLexer.g3:1:476: OP_Bar
			{
			DebugLocation(1, 476);
			mOP_Bar(); 

			}
			break;
		case 53:
			DebugEnterAlt(53);
			// RppLexer.g3:1:483: OP_Unary
			{
			DebugLocation(1, 483);
			mOP_Unary(); 

			}
			break;
		case 54:
			DebugEnterAlt(54);
			// RppLexer.g3:1:492: OP_Ops
			{
			DebugLocation(1, 492);
			mOP_Ops(); 

			}
			break;
		case 55:
			DebugEnterAlt(55);
			// RppLexer.g3:1:499: BooleanLiteral
			{
			DebugLocation(1, 499);
			mBooleanLiteral(); 

			}
			break;
		case 56:
			DebugEnterAlt(56);
			// RppLexer.g3:1:514: Id
			{
			DebugLocation(1, 514);
			mId(); 

			}
			break;
		case 57:
			DebugEnterAlt(57);
			// RppLexer.g3:1:517: NewLine
			{
			DebugLocation(1, 517);
			mNewLine(); 

			}
			break;
		case 58:
			DebugEnterAlt(58);
			// RppLexer.g3:1:525: IntegerLiteral
			{
			DebugLocation(1, 525);
			mIntegerLiteral(); 

			}
			break;
		case 59:
			DebugEnterAlt(59);
			// RppLexer.g3:1:540: FloatingPointLiteral
			{
			DebugLocation(1, 540);
			mFloatingPointLiteral(); 

			}
			break;
		case 60:
			DebugEnterAlt(60);
			// RppLexer.g3:1:561: InterpolatedStringLiteral
			{
			DebugLocation(1, 561);
			mInterpolatedStringLiteral(); 

			}
			break;
		case 61:
			DebugEnterAlt(61);
			// RppLexer.g3:1:587: StringLiteral
			{
			DebugLocation(1, 587);
			mStringLiteral(); 

			}
			break;
		case 62:
			DebugEnterAlt(62);
			// RppLexer.g3:1:601: WS
			{
			DebugLocation(1, 601);
			mWS(); 

			}
			break;

		}

	}


	#region DFA
	DFA22 dfa22;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa22 = new DFA22(this);
	}

	private class DFA22 : DFA
	{
		private const string DFA22_eotS =
			"\x1\xFFFF\x11\x27\x9\xFFFF\x1\x4C\x1\x4D\x1\x4F\x1\x23\x1\xFFFF\x1\x51"+
			"\x1\x52\x1\x53\x1\xFFFF\x2\x53\x3\xFFFF\x1\x54\x2\xFFFF\x6\x27\x1\x5D"+
			"\x5\x27\x1\x63\xA\x27\x1\xFFFF\x7\x27\xA\xFFFF\x7\x27\x1\x7F\x1\xFFFF"+
			"\x3\x27\x1\x84\x1\x27\x1\xFFFF\x3\x27\x1\x8A\x8\x27\x1\x93\x2\x27\x1"+
			"\x96\x1\x97\x7\x27\x1\x9F\x2\x27\x1\xFFFF\x1\xA2\x3\x27\x1\xFFFF\x3\x27"+
			"\x1\xA9\x1\x27\x1\xFFFF\x1\xAB\x7\x27\x1\xFFFF\x1\xB3\x1\xB4\x2\xFFFF"+
			"\x1\x27\x1\xB6\x5\x27\x1\xFFFF\x1\xBC\x1\xBD\x1\xFFFF\x1\x27\x1\xBF\x1"+
			"\x27\x1\xB3\x2\x27\x1\xFFFF\x1\xC3\x1\xFFFF\x4\x27\x1\xC8\x1\xC9\x1\xCA"+
			"\x2\xFFFF\x1\xCB\x1\xFFFF\x1\xCC\x4\x27\x2\xFFFF\x1\x27\x1\xFFFF\x2\x27"+
			"\x1\xD4\x1\xFFFF\x1\xD5\x1\x27\x1\xD7\x1\xD8\x5\xFFFF\x1\xD9\x1\xDA\x2"+
			"\x27\x1\xDD\x1\xDE\x1\x27\x2\xFFFF\x1\x27\x4\xFFFF\x1\x27\x1\xE2\x2\xFFFF"+
			"\x1\xE3\x1\xE4\x1\xE5\x4\xFFFF";
		private const string DFA22_eofS =
			"\xE6\xFFFF";
		private const string DFA22_minS =
			"\x1\x9\x1\x61\x1\x62\x1\x61\x1\x65\x1\x6C\x1\x61\x1\x66\x2\x61\x1\x65"+
			"\x1\x62\x1\x65\x1\x22\x1\x68\x1\x61\x1\x68\x1\x69\x9\xFFFF\x1\x3D\x1"+
			"\x30\x1\x3D\x1\x3A\x1\xFFFF\x1\x30\x2\x3D\x1\xFFFF\x2\x3D\x3\xFFFF\x1"+
			"\x2E\x2\xFFFF\x1\x63\x1\x69\x2\x73\x1\x61\x1\x66\x1\x30\x1\x73\x1\x74"+
			"\x1\x6E\x1\x72\x1\x6C\x1\x30\x1\x70\x1\x7A\x1\x74\x1\x77\x1\x6C\x1\x6A"+
			"\x1\x65\x1\x74\x1\x61\x1\x70\x1\xFFFF\x1\x72\x1\x61\x1\x70\x1\x6C\x1"+
			"\x69\x1\x74\x1\x65\xA\xFFFF\x1\x6B\x1\x76\x2\x74\x1\x65\x1\x63\x1\x73"+
			"\x1\x30\x1\xFFFF\x2\x65\x1\x61\x1\x30\x1\x73\x1\xFFFF\x1\x6C\x1\x79\x1"+
			"\x63\x1\x30\x1\x6C\x1\x65\x1\x72\x1\x75\x1\x6C\x1\x65\x1\x6F\x1\x69\x1"+
			"\x30\x2\x65\x2\x30\x1\x6C\x1\x68\x1\x6C\x2\x61\x1\x65\x1\x72\x1\x30\x1"+
			"\x68\x1\x73\x1\xFFFF\x1\x30\x1\x6E\x1\x6C\x1\x6F\x1\xFFFF\x1\x65\x1\x69"+
			"\x1\x72\x1\x30\x1\x68\x1\xFFFF\x1\x30\x1\x63\x2\x72\x1\x65\x1\x72\x1"+
			"\x77\x1\x74\x1\xFFFF\x2\x30\x2\xFFFF\x1\x65\x1\x30\x1\x64\x1\x67\x1\x74"+
			"\x1\x63\x1\x61\x1\xFFFF\x2\x30\x1\xFFFF\x1\x64\x1\x30\x1\x6D\x1\x30\x1"+
			"\x63\x1\x74\x1\xFFFF\x1\x30\x1\xFFFF\x1\x74\x1\x69\x1\x6E\x1\x64\x3\x30"+
			"\x2\xFFFF\x1\x30\x1\xFFFF\x1\x30\x2\x65\x1\x74\x1\x63\x2\xFFFF\x1\x73"+
			"\x1\xFFFF\x1\x65\x1\x69\x1\x30\x1\xFFFF\x1\x30\x1\x64\x2\x30\x5\xFFFF"+
			"\x2\x30\x1\x65\x1\x74\x2\x30\x1\x74\x2\xFFFF\x1\x65\x4\xFFFF\x1\x64\x1"+
			"\x30\x2\xFFFF\x3\x30\x4\xFFFF";
		private const string DFA22_maxS =
			"\x1\x7E\x1\x72\x1\x62\x1\x6C\x1\x6F\x1\x78\x1\x6F\x1\x6D\x2\x61\x1\x75"+
			"\x1\x76\x1\x65\x1\x75\x1\x79\x1\x61\x2\x69\x9\xFFFF\x1\x3E\x1\x39\x1"+
			"\x3D\x1\x3A\x1\xFFFF\x1\x7A\x1\x7C\x1\x3D\x1\xFFFF\x2\x3D\x3\xFFFF\x1"+
			"\x39\x2\xFFFF\x1\x63\x1\x6F\x1\x73\x1\x74\x1\x61\x1\x66\x1\x7A\x1\x73"+
			"\x1\x74\x1\x6E\x1\x72\x1\x6C\x1\x7A\x1\x70\x1\x7A\x1\x74\x1\x77\x1\x6C"+
			"\x1\x6A\x1\x65\x1\x74\x1\x61\x1\x70\x1\xFFFF\x1\x72\x1\x79\x1\x70\x1"+
			"\x72\x1\x69\x1\x74\x1\x65\xA\xFFFF\x1\x6B\x1\x76\x2\x74\x1\x65\x1\x63"+
			"\x1\x73\x1\x7A\x1\xFFFF\x2\x65\x1\x61\x1\x7A\x1\x73\x1\xFFFF\x1\x6F\x1"+
			"\x79\x1\x63\x1\x7A\x1\x6C\x1\x65\x1\x72\x1\x75\x1\x6C\x1\x65\x1\x6F\x1"+
			"\x69\x1\x7A\x2\x65\x2\x7A\x1\x6C\x1\x68\x1\x6C\x2\x61\x1\x65\x1\x72\x1"+
			"\x7A\x1\x68\x1\x73\x1\xFFFF\x1\x7A\x1\x6E\x1\x6C\x1\x6F\x1\xFFFF\x1\x65"+
			"\x1\x69\x1\x72\x1\x7A\x1\x68\x1\xFFFF\x1\x7A\x1\x63\x2\x72\x1\x65\x1"+
			"\x72\x1\x77\x1\x74\x1\xFFFF\x2\x7A\x2\xFFFF\x1\x65\x1\x7A\x1\x64\x1\x67"+
			"\x1\x74\x1\x63\x1\x61\x1\xFFFF\x2\x7A\x1\xFFFF\x1\x64\x1\x7A\x1\x6D\x1"+
			"\x7A\x1\x63\x1\x74\x1\xFFFF\x1\x7A\x1\xFFFF\x1\x74\x1\x69\x1\x6E\x1\x64"+
			"\x3\x7A\x2\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x2\x65\x1\x74\x1\x63\x2\xFFFF"+
			"\x1\x73\x1\xFFFF\x1\x65\x1\x69\x1\x7A\x1\xFFFF\x1\x7A\x1\x64\x2\x7A\x5"+
			"\xFFFF\x2\x7A\x1\x65\x1\x74\x2\x7A\x1\x74\x2\xFFFF\x1\x65\x4\xFFFF\x1"+
			"\x64\x1\x7A\x2\xFFFF\x3\x7A\x4\xFFFF";
		private const string DFA22_acceptS =
			"\x12\xFFFF\x1\x24\x1\x25\x1\x26\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B\x1"+
			"\x2C\x4\xFFFF\x1\x32\x3\xFFFF\x1\x36\x2\xFFFF\x1\x35\x1\x38\x1\x39\x1"+
			"\xFFFF\x1\x3D\x1\x3E\x17\xFFFF\x1\x3C\x7\xFFFF\x1\x2D\x1\x2E\x1\x2F\x1"+
			"\x3B\x1\x30\x1\x31\x1\x33\x1\x34\x1\x35\x1\x3A\x8\xFFFF\x1\x7\x5\xFFFF"+
			"\x1\xD\x1B\xFFFF\x1\x6\x4\xFFFF\x1\xB\x5\xFFFF\x1\x12\x8\xFFFF\x1\x1D"+
			"\x2\xFFFF\x1\x1F\x1\x20\x7\xFFFF\x1\x3\x2\xFFFF\x1\x8\x6\xFFFF\x1\x10"+
			"\x1\xFFFF\x1\x13\x7\xFFFF\x1\x37\x1\x1E\x1\xFFFF\x1\x22\x5\xFFFF\x1\x4"+
			"\x1\x5\x1\xFFFF\x1\xA\x3\xFFFF\x1\x11\x4\xFFFF\x1\x1A\x1\x1B\x1\x1C\x1"+
			"\x21\x1\x23\x7\xFFFF\x1\xF\x1\x14\x1\xFFFF\x1\x18\x1\x19\x1\x1\x1\x16"+
			"\x2\xFFFF\x1\x9\x1\xC\x3\xFFFF\x1\x2\x1\xE\x1\x15\x1\x17";
		private const string DFA22_specialS =
			"\xE6\xFFFF}>";
		private static readonly string[] DFA22_transitionS =
			{
				"\x1\x2B\x1\x28\x1\xFFFF\x1\x2B\x1\x28\x12\xFFFF\x1\x2B\x1\x25\x1\x2A"+
				"\x2\xFFFF\x2\x23\x1\xFFFF\x1\x18\x1\x19\x1\x1D\x1\x22\x1\x17\x1\x24"+
				"\x1\x1C\x1\x23\xA\x29\x1\x1A\x1\x12\x1\x1E\x1\x1B\x1\x23\x1\xFFFF\x1"+
				"\x1F\x1A\x27\x1\x13\x1\xFFFF\x1\x14\x1\x23\x1\x20\x1\xFFFF\x1\x2\x1"+
				"\x27\x1\x3\x1\x4\x1\x5\x1\x6\x2\x27\x1\x7\x2\x27\x1\x8\x1\x9\x1\xA\x1"+
				"\xB\x1\x1\x1\x27\x1\xC\x1\xD\x1\xE\x1\x27\x1\xF\x1\x10\x1\x27\x1\x11"+
				"\x1\x27\x1\x15\x1\x21\x1\x16\x1\x26",
				"\x1\x2C\x10\xFFFF\x1\x2D",
				"\x1\x2E",
				"\x1\x2F\xA\xFFFF\x1\x30",
				"\x1\x31\x9\xFFFF\x1\x32",
				"\x1\x33\xB\xFFFF\x1\x34",
				"\x1\x37\x7\xFFFF\x1\x35\x5\xFFFF\x1\x36",
				"\x1\x38\x6\xFFFF\x1\x39",
				"\x1\x3A",
				"\x1\x3B",
				"\x1\x3C\xF\xFFFF\x1\x3D",
				"\x1\x3E\x13\xFFFF\x1\x3F",
				"\x1\x40",
				"\x1\x43\x42\xFFFF\x1\x41\xF\xFFFF\x1\x42",
				"\x1\x44\x9\xFFFF\x1\x45\x6\xFFFF\x1\x46",
				"\x1\x47",
				"\x1\x48\x1\x49",
				"\x1\x4A",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x23\x1\x4B",
				"\xA\x4E",
				"\x1\x23",
				"\x1\x50",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\x23\x3E\xFFFF\x1\x23",
				"\x1\x23",
				"",
				"\x1\x23",
				"\x1\x23",
				"",
				"",
				"",
				"\x1\x4E\x1\xFFFF\xA\x29",
				"",
				"",
				"\x1\x55",
				"\x1\x56\x5\xFFFF\x1\x57",
				"\x1\x58",
				"\x1\x59\x1\x5A",
				"\x1\x5B",
				"\x1\x5C",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\x5E",
				"\x1\x5F",
				"\x1\x60",
				"\x1\x61",
				"\x1\x62",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\x64",
				"\x1\x65",
				"\x1\x66",
				"\x1\x67",
				"\x1\x68",
				"\x1\x69",
				"\x1\x6A",
				"\x1\x6B",
				"\x1\x6C",
				"\x1\x6D",
				"",
				"\x1\x6E",
				"\x1\x6F\x13\xFFFF\x1\x71\x3\xFFFF\x1\x70",
				"\x1\x72",
				"\x1\x73\x5\xFFFF\x1\x74",
				"\x1\x75",
				"\x1\x76",
				"\x1\x77",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x78",
				"\x1\x79",
				"\x1\x7A",
				"\x1\x7B",
				"\x1\x7C",
				"\x1\x7D",
				"\x1\x7E",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"\x1\x80",
				"\x1\x81",
				"\x1\x82",
				"\xA\x27\x7\xFFFF\x12\x27\x1\x83\x7\x27\x6\xFFFF\x1A\x27",
				"\x1\x85",
				"",
				"\x1\x86\x2\xFFFF\x1\x87",
				"\x1\x88",
				"\x1\x89",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\x8B",
				"\x1\x8C",
				"\x1\x8D",
				"\x1\x8E",
				"\x1\x8F",
				"\x1\x90",
				"\x1\x91",
				"\x1\x92",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\x94",
				"\x1\x95",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\x98",
				"\x1\x99",
				"\x1\x9A",
				"\x1\x9B",
				"\x1\x9C",
				"\x1\x9D",
				"\x1\x9E",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xA0",
				"\x1\xA1",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xA3",
				"\x1\xA4",
				"\x1\xA5",
				"",
				"\x1\xA6",
				"\x1\xA7",
				"\x1\xA8",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xAA",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xAC",
				"\x1\xAD",
				"\x1\xAE",
				"\x1\xAF",
				"\x1\xB0",
				"\x1\xB1",
				"\x1\xB2",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"",
				"\x1\xB5",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xB7",
				"\x1\xB8",
				"\x1\xB9",
				"\x1\xBA",
				"\x1\xBB",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"\x1\xBE",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xC0",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xC1",
				"\x1\xC2",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"\x1\xC4",
				"\x1\xC5",
				"\x1\xC6",
				"\x1\xC7",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xCD",
				"\x1\xCE",
				"\x1\xCF",
				"\x1\xD0",
				"",
				"",
				"\x1\xD1",
				"",
				"\x1\xD2",
				"\x1\xD3",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xD6",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"",
				"",
				"",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xDB",
				"\x1\xDC",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\x1\xDF",
				"",
				"",
				"\x1\xE0",
				"",
				"",
				"",
				"",
				"\x1\xE1",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"\xA\x27\x7\xFFFF\x1A\x27\x6\xFFFF\x1A\x27",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA22_eot = DFA.UnpackEncodedString(DFA22_eotS);
		private static readonly short[] DFA22_eof = DFA.UnpackEncodedString(DFA22_eofS);
		private static readonly char[] DFA22_min = DFA.UnpackEncodedStringToUnsignedChars(DFA22_minS);
		private static readonly char[] DFA22_max = DFA.UnpackEncodedStringToUnsignedChars(DFA22_maxS);
		private static readonly short[] DFA22_accept = DFA.UnpackEncodedString(DFA22_acceptS);
		private static readonly short[] DFA22_special = DFA.UnpackEncodedString(DFA22_specialS);
		private static readonly short[][] DFA22_transition;

		static DFA22()
		{
			int numStates = DFA22_transitionS.Length;
			DFA22_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA22_transition[i] = DFA.UnpackEncodedString(DFA22_transitionS[i]);
			}
		}

		public DFA22( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 22;
			this.eot = DFA22_eot;
			this.eof = DFA22_eof;
			this.min = DFA22_min;
			this.max = DFA22_max;
			this.accept = DFA22_accept;
			this.special = DFA22_special;
			this.transition = DFA22_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( KW_Package | KW_Abstract | KW_Case | KW_Catch | KW_Class | KW_Def | KW_Do | KW_Else | KW_Extends | KW_Final | KW_For | KW_ForSome | KW_If | KW_Implicit | KW_Import | KW_Lazy | KW_Match | KW_New | KW_Null | KW_Object | KW_Override | KW_Private | KW_Protected | KW_Return | KW_Sealed | KW_Super | KW_Throw | KW_Trait | KW_Try | KW_Type | KW_Val | KW_Var | KW_While | KW_With | KW_Yield | OP_Semi | OP_LBracket | OP_RBracket | OP_LBrace | OP_RBrace | OP_Comma | OP_LParen | OP_RParen | OP_Colon | OP_Follow | OP_Eq | OP_Dot | OP_Star | OP_Upper | OP_At | OP_Underscore | OP_Bar | OP_Unary | OP_Ops | BooleanLiteral | Id | NewLine | IntegerLiteral | FloatingPointLiteral | InterpolatedStringLiteral | StringLiteral | WS );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion

}

} // namespace CSharpRpp
